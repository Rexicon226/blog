---
.title = "Twisted ElGamal and Pedersen Commitments",
.date = @date("2025-05-16T00:00:00"),
.author = "David Rubin",
.layout = "post.shtml",
.draft = false,
--- 

# Introduction

Modern cryptography is full of interesting ideas that hide secrets in plain sight.
Two such ideas, the ones we'll be discussing in this post, are 
[ElGamal Encryption](https://en.wikipedia.org/wiki/ElGamal_encryption) and 
[Pedersen Commitments](https://www.zkdocs.com/docs/zkdocs/commitments/pedersen).
These are well-known staples in privacy-preserving protocols, from zero-knowledge
proofs to blockchain privacy layers.

I hope to demystify some of the math behind them. You don't need a degree in
abstract algebra to understand - but you'll get to see the formulas, gain an intuition
about the subject, and understand *why* they work, all from the perspective of 
computer science ideas like modular arithmetics, hash functions, and "trapdoor" 
functions.

## [Background]($section.id('background'))

Let's first set the stage and talk about a few things.

- [Modular Arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic)
- [Cyclic Groups](https://en.wikipedia.org/wiki/Cyclic_group)
- [Discrete Log Problem](https://en.wikipedia.org/wiki/Discrete_logarithm)

## [Modular Arithmetics]($section.id('modular_math'))

If you've worked on hashing, pseudo-random number generators,
or maybe some low-level bit flipping tricks,
you've probably come across this idea. 

```
(a + b) % n
```

These particular arithmetics are "modular" because they work around a modular ring.
When you perform an operation between two elements, if the result ends up larger
than the `n` value, we "reduce" or "wrap" it back.

```
(2 + 10) % 7
12 % 7
5
```
```
(4 * 4) % 7
16 % 7
2
```

This means that no matter what the inputs are to the addition or multiplication
in our example, the result will always lie in the set of numbers,

```
{0, 1, 2, 3, 4, 5, 6}
```

In cryptography, we often work with this concept in the form of 
finite integer sets, denoted by [`\mathbb{Z}_P`](/$).
This notation is describing a "set of integers" (that's the fancy Z), where
the set looks like:

```
{0, 1, ..., p - 2, p - 1}
```

Looking at the examples given before, we can describe the modular ring,
the `N % 7`, as [`\mathbb{Z}_7`](/$). The largest number of the set
is 6, i.e `13 % 7 == 6`.

Now, this [`\mathbb{Z}_P`](/$) set is closed under addition, subtraction,
and multiplication, so it is considered a **ring**. But for our purposes in 
cryptography, we often want a **group**, which is a set where all operations have
inverses.

The problem occurs when we consider multiplication and the zero element of the set.

In a group, every element must have an **inverse**. That means:

For every [`a`](/$), there exists an [`a^{-1}`](/$) such that:

```=mathtex
a * a^{-1} \equiv 1 mod p
```

But **zero has no inverse**. There's no number *x* such that:

```=mathtex
0 * x \equiv 1 mod p
```

No matter what you multiply 0 by, you always get 0. So zero **breaks** the inverse requirement,
which disqualifies [`\mathbb{Z}_P`](/$) as a multiplicative group.

To fix this problem, we just **remove zero from the set**:

```=mathtex
\mathbb{Z}_p^* = \{1, 2, ..., p - 1\}
```

This set is a group under multiplicative modulo [`p`](/$), 
as long as [`p`](/$) is a prime number.

This works because:

- Every non-zero number [`a \in \mathbb{Z}_p^*`](/$) has a modular inverse
[`a^{-1} \in \mathbb{Z}_p^*`](/$)
- Modular multiplication is associative
- There's an identity element (1)
- And now, every element has an inverse - including `1` and [`p - 1`](/$).

Think of 0 as a "trapdoor" in multiplication: once you fall into it, you can't
get out. This is why cryptographic constructions often avoid it in multiplicative groups.

It can also cause serious security issues, which is why 
[cryptography libraries often disallow zero elements](https://github.com/ziglang/zig/blob/8e72a25285b5e782ee44828b6d1904d91fb16a29/lib/std/crypto/25519/edwards25519.zig#L248).


## [Cyclic Groups]($section.id('cyclic_groups'))

Next, we need to understand what cyclic groups are and why they're important.

Imagine you have a number [`g`](/$), and you start raising it to powers - modulo some prime
number [`p`](/$).

```=mathtex
g^1 mod p, g^2 mod p, g^3 mod p, ...
```

Eventually, due to the wrapping nature of modular arithmetics, the results loop
back around, and you'll get 1 again. The set of all these results is a **cyclic group**,
and the number [`g`](/$) that generates them is called a **generator** of the group.

A group [`\mathbb{G}`](/$) is considered cyclic if there exists an element
[`g \in \mathbb{G}`](/$) such that the cyclic subgroup generated by [`g`](/$), 
meaning the set which contains all powers of [`g`](/$) up to `n - 1` equals
[`\mathbb{G}`](/$). That is:

```=mathtex
\mathbb{G} = \{g^0, g^1, ..., g^{n - 1}\}
```

where `n` is the size of the group. All powers are computed modulo some number,
usually a prime.

If you're working with integers modulo a prime [`p`](/$), the group 
[`\mathbb{Z}_p^* = \{1, 2, 3, ..., p - 1\}`](/$) is a **multiplicative
cyclic group** of size `p - 1`. Some number [`g \in \mathbb{Z}_p^*`](/$)
is a **generator** if:

```=mathtex
\{g^1 mod p, g^2 mod p, g^3 mod p, ..., g^{p - 1} mod p\} = \mathbb{Z}_p^*
```

This means that just by knowing [`g`](/$), you can reach any number in the group by raising
it to the right power. 

This property is important for the concepts we're exploring in this post. 
Raising [`g`](/$) to a power [`x`](/$) is **easy**:
```
y = pow(g, x, p)
```

But given [`y = g^x mod p`](/$), trying to figure out what [`x`](/$) was is **hard**.
This is the core of the **Discrete Logarithm Problem** (DLP), and it's
what makes schemes like Pedersen commitments and ElGamal encryption secure.

You can think of it like a hash function - one-way, deterministic, and extremely
hard to invert.

A couple more thoughts on cyclic groups regarding cryptography:

They are useful since they are both compact and efficient; you only
need to store one number [`g`](/$) to define the whole group, and you can 
jump to any element with exponentiation. 

Not all groups are "good" when it comes to security. Some groups are not cyclic,
they don't have a single generator that can reach every element in the set. Others
are cyclic but not secure (either the group is too small or DLP is easy). That's
why cryptographic applications use very specific kinds of cyclic groups:

- Multiplicative groups where [`p`](/$) is a (very) large prime
- Elliptic curve groups, but those are for another blog post.

## [Discrete Log Problem]($section.id('dlp')) 

I've mentioned DLP a few times now, but let's take a moment to understand what is
so important about it. At the heart of many cryptographic systems is one 
simple question:

> If I give you [`y = g^x mod p`](/$), can you figure out what [`x`](/$) is?

In everyday math, this would be like solving:

```=mathtex
y = g^x \Rightarrow x = log_g(y)
```

But in **modular arithmetic**, logarithms behave very differently. Given:

```=mathtex
y = g^x mod p
```

There is no shortcut for recovering [`x`](/$), for a large enough [`p`](/$), 
the only option is to test every possible element of the set. 

When encrypting or signing, schemes use *exponentiation* as discussed in the cyclic
groups chapter. There are algorithms for this that have logarithmic complexity
in relation to the number of group elements: [`\mathcal{O}(|n|)`](/$). Considering
that in the brute-force algorithm we need to exponentiate each element,
the time complexity of the algorithm is [`\mathcal{O}(2^{|n|})`](/$).

For a secure cyclic group, this means that it is practically unsolvable for our
modern computational resources. However, it is of course possible to have an 
*insecure* group, where the DLP is relatively speaking "easy" to solve, or
possible in polynomial time.

The simplest way to make your group more secure is to have a very 
large order (the number of elements in the set). 256-bit primes are a common
way to achieve this, with the famous Curve25519 having the order [`2^{255}-19`](/$).
Unfortunately, there exist other properties that can weaken the group, one
of the most common being "weak subgroups".

A subgroup is simply a smaller set of elements within a group that still follows
the same group rules. That is, if you take any two elements from the subgroup
and multiply them together, you stay within the subgroup.

For example, suppose you're working with the multiplicative group
[`\mathbb{Z}_p^*`](/$). A **subgroup** might be a smaller set of numbers
within [`\mathbb{Z}_p^*`](/$) that also loop around nicely when you raise
them to powers. Every subgroup has a **generator** - 
just like with the full group - and an **order**.

Small subgroups are a big problem in cryptography because they **shrink
the space an attacker has to search** when brute forcing. If an attacker
can trick your system into operating inside a small subgroup, they might
only need to try a handful of values to brute-force secrets like exponents
or keys.

There are plenty of sources that go into further detail about this problem:

- [Logjam Attack](https://weakdh.org/)
- [CVE-2002-20001](https://www.watchguard.com/wgrd-psirt/advisory/wgsa-2024-00008)
- [RFC 2785](https://www.rfc-editor.org/rfc/rfc2785.txt)
- [CVE-2017-9248](https://nvd.nist.gov/vuln/detail/CVE-2017-9248)

To avoid these security issues, it's important to 
[perform subgroup membership checks](https://github.com/firedancer-io/firedancer/blob/45cdc04230210cc4c9e31b3e7f67058267a22a84/src/ballet/bn254/fd_bn254_g2.c#L354-L391)
for groups where the order isn't a prime number.

# [Pedersen Commitments]($section.id('pedersen_commitment'))

In cryptography, a **commitment scheme** lets you *lock in a value* while 
keeping it hidden - like sealing a message in an envelope. Later, you can open
the envelope to reveal what you committed to. This simple idea is a foundational
building block in many cryptographic protocols, from zero-knowledge proofs to secure
voting systems.

A good commitment scheme must have two important properties:

- **Hiding**: The commitment doesn't reveal anything about the value being committed.
Until you open it, it should look completely random.
- **Binding**: Once you've committed to a value, you can't change your mind. 
You're "locked in."

These two properties are in tension. Hiding ensures the commitment gives away
no information about the underlying value; binding ensures you can't cheat and
claim you committed to a different value later.

Think of a physical safe: you can put a piece of paper inside, lock it,
and show someone the locked safe. They can't see what's inside (hiding), 
and once it's locked, you can't change what's in it without being 
noticed (binding). When you give them the combination later, they can verify
that what you committed to was in the safe all along.

In the digital world, the "safe" is a short piece of cryptographic data 
(a commitment) - typically much smaller than the original value -
but it plays the same role.

### [Going through the math]($section.id('pedersen_math'))

Now let's take a look at Pedersen commitments from a mathematical point of 
view. The magic of this scheme comes from using a group with **two generators**.

A Pedersen commitment to a value *m* (the number you want to **commit** to) is 
computed as:

```=mathtex
C = g^m \cdot h^r mod p
```

- where [`g`](/$) and [`h`](/$) are the **generators** of a group
- [`r`](/$) is a random value (called the **blinding factor**), chosen to hide [`m`](/$)
- [`p`](/$) is a large prime, and the group is typically a multiplicative subgroup of 
[`\mathbb{Z}_p^*`](/$) or a point group on an elliptic curve

The commitment [`C`](/$) looks random to anyone who doesn't know both 
[`m`](/$) and [`r`](/$), but you can "open" the commitment later by 
revealing those two values.

Now you may be wondering, why do we need **two** generators? Shouldn't the 
Discrete Log Problem be enough to mask the value of the commitment if we just
used:

```=mathtex
C = g^m mod p 
```

The issue is that [`m`](/$) is a user-defined value, and could be anything. Commonly
in confidential transactions, [`m`](/$) is a relatively small number such as the 
account balance, which would lead to brute-force attacks being easy. 

A second generator point "masks" [`m`](/$) behind the randomness of [`r`](/$).
Now, even if [`m`](/$) is 0, 1, 2, or some small-ish number, the commitment
looks random unless you know what [`r`](/$) is. Thanks to the unknown
discrete log between [`g`](/$) and [`h`](/$), there's no way to remove 
the blinding factor from the commitment without solving the **two DLPs at once**,
which is *still* hard. This becomes what's called the 
[computational Diffie-Hellman problem](https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption)
(CDH).

### [Additive Homomorphism]($section.id('additive_homomorphism'))

Pedersen commitments have a nifty property: **they are additively homomorphic**.
This means you can combine two commitments, resulting in a commitment to the sum.

Let's say:

```=mathtex
\begin{aligned}
C_1 = g^{m_1} \cdot g^{r_1} \\
C_2 = g^{m_2} \cdot g^{r_2}
\end{aligned}
```

Then:

```=mathtex
C_1 \cdot C_2 = g^{m_1 + m_2} \cdot h^{r_1 + r_2}
```

So [`C_1 \cdot C_2`](/$) is a valid commitment to [`m_1 + m_2`](/$) using
blinding factor [`r_1 + r_2`](/$). 

This property makes Pedersen commitments especially useful in protocols where
you want to prove things **about hidden values** without revealing them. 
For instance, showing that the sum of committed inputs equals the sum of
committed outputs in a confidential transaction.


### [Why is it secure?]($section.id('pedersen_secure'))

The **binding** property depends on a very important assumption:

> Given a commitment [`C = g^m \cdot h^r`](/$), it should be *infeasible*
to find two different pairs [`(m_1, r_1)`](/$) and [`(m_2, r_2)`](/$)
such that:

```=mathtex
g^{m_1} \cdot h^{r_1} = g^{m_2} \cdot h^{r_2}
```

Unless you know the discrete log between [`g`](/$) and [`h`](/$), you 
cannot find two valid openings. And without the ability to find
another valid opening after creating the first one, you're unable to 
later claim you committed to something else.

This means the commitment scheme is **computationally binding** - it's secure
against these sorts of attacks as long as DLP is hard. If an attacker had infinite time,
they would potentially be able to find a second opening for the same commitment.

The flip side of this is **perfectly-binding**, meaning even if an attacker had
infinite time, they wouldn't be able to find a second opening. For this to be the
case, each value of [`m`](/$) would need to have a single opening, which is **not**
the case for Pedersen commitments.

---

The **hiding** property ensures that the commitment doesn't leak any information
about [`m`](/$) - not even partial hints. With Pedersen commitments:

> As long as the blinding factor [`r`](/$) is chosen randomly and independently,
the commitment [`C = g^m \cdot h^r`](/$) is **perfectly hiding**.

What does that mean?

- For any two possible messages [`m_1`](/$) and [`m_2`](/$), the commitments
[`C_1`](/$) and  [`C_2`](/$) look **identically distributed** if the random
[`r`](/$) values are chosen uniformly.
- This is true **regardless of how powerful the attacker is** - even if they had 
infinite time, they couldn't distinguish whether [`C`](/$) hides [`m_1`](/$) or
[`m_2`](/$).

This property is called **information-theoretic hiding** or **perfectly-hiding**: 
the message is completely masked by the randomness, not just "hard to guess" 
via brute-force methods.

Something to note is that commitment schemes **cannot** be both perfectly-hiding 
*and* perfectly-binding. It's physically impossible. In order to be perfectly-hiding,
two different messages must be able to produce the same commitment. But if that 
were to be the case, then the commitment can be opened in two ways, so the scheme
is not perfectly binding.

Pedersen commitments are perfectly-hiding and computationally binding.

## [ElGamal Encryption]($section.id('elgamal_algorithm'))

ElGamal encryption is a public-key encryption scheme built on the 
Discrete Logarithm Problem - the same hard problem that underpins
the previously discussed Pedersen commitments.

At its core, ElGamal lets someone encrypt a message so that *only* the recipient
(who knows a secret key) can decrypt it - and it does so in a way that 
allows us to reuse much of the math we've already seen in this post.

Where Pedersen commitments let us hide a value in a way that can be later
revealed, ElGamal lets us send a value in a way that can later be decrypted - 
but only by the intended recipient.

It uses the same kind of group:

- A generator [`g`](/$)
- A secret key [`x`](/$)
- A public key [`pk = g^x`](/$)


ElGamal is similar to Pedersen commitments because they share a useful property.
ElGamal is **homomorphic**. This means you can add or multiply encrypted
values together, and the result will still decrypt properly. This makes
it useful for privacy-preserving computation, voting protocols, threshold decryption,
and a ton of other things.

If you understand Pedersen commitments, ElGamal encryption will feel very similar.

|            | Pedersen Commitment                    | ElGamal Encryption               |
| ---------- | -------------------------------------- | -------------------------------  |
| Purpose    | Lock in a value                        | Encrypt a value                  |
| Formula    | [`C = g^m \cdot h^r`](/$)              | [`ct = (g^r, pk^r \cdot m)`](/$) |
| Randomness | [`r`](/$) blinding factor              | [`r`](/$) encrpytion randomness  |
| Security   | Hiding via randomness, binding via DLP | Indistinguishability via DLP     |

Both use **exponentiation in a cyclic group** - either a multiplicative group like 
[`\mathbb{Z}_p^*`](/$), or an elliptic curve group - both rely on the assumption
that DLP is hard in that group.

When used with elliptic curves (EC), ElGamal simply switches from exponentiation [`g^x`](/$)
to scalar multiplication [`x \cdot G`](/$). The mathematical structure is the same,
but EC offers much smaller key sizes for the same security level.

The best known attacks (such as number field sieve) scale 
**sub-exponentially** with the size of [`p`](/$), so to get strong security,
256-bit symmetric equivalent, you'd need a group with order in the thousands 
of bits (3072, 7680, 15360 bits).

### [ElGamal Decryption Example]($section.id('elgamal_decrypt'))

Let's quickly go through an example of the decryption process for ElGamal
to get a better understanding of the algorithm overall.

Let's assume you're working in a group [`\mathbb{G}`](/$) with generator
[`g`](/$).

Quick note: [`\overset{\$}{\leftarrow}`](/$) means "a scalar uniformally distributed
from the set".


- Private key: [`x \overset{\$}{\leftarrow} \mathbb{Z}_{p - 1}^*`](/$).
It's important that [`p - 1`](/$) isn't included in the set, since there 
wouldn't be much work for the adversary if your private key results
in a public key equivalent to the generator.
- Public key: [`h = g^x`](/$)

To encrypt a message [`m \in \mathbb{G}`](/$), the sender picks a random
element [`r \overset{\$}{\leftarrow} \mathbb{Z}_p`](/$), and sends the ciphertext:

- [`c_1 = g^r`](/$)
- [`c_2 = m \cdot h^r`](/$)

The ciphertext is the pair [`(c_1, c_2)`](/$)

The receiver (who knows the secret key [`x`](/$)) gets the ciphertext 
[`(c_1, c_2)`](/$), where again:

- [`c_1 = g^r`](/$)
- [`c_2 = m \cdot h^r = m \cdot (g^x)^r = m \cdot g^{xr}`](/$)

To recover the message [`m`](/$), they compute:

```=mathtex
m = c_2 \cdot (c_1^x)^{-1}
```

This works because:

```=mathtex
\begin{align}
c_1^x = (g^r)^x = g^{xr} \\
c_2 = m \cdot g^{xr} \\
m = c_2 \cdot (g^{xr})^{-1} = m \cdot g^{xr} \cdot g^{-xr} = m
\end{align}
```

The sender "blinds" the message by multiplying it with a one-time pad
[`h^r`](/$). The receiver knows how to "unwind" that one-time pad via
their private key. The security of the algorithm comes from not being
able to compute [`x`](/$) from [`h = g^x`](/$).

### [What is Twisted ElGamal]($section.id('twisted_elgamal'))

As discussed in the previous chapter, ElGamal encryption operates
by encrypting messages that are elements of the cyclic group [`\mathbb{G}`](/$).
The main limitation of this approach which becomes particularly apparent 
with integrating in zero-knowledge proofs is handling of messages
not naturally residing in [`\mathbb{G}`](/$).

Twisted ElGamal encryption addresses these limitations by combining the previously
discussed ideas and restructing the ciphertext into two compontents:

- A Pedersen Commitment: [`C = r \cdot H + m \cdot G`](/$)
- A Decryption Handle: [`D = r \cdot P`](/$)

In this setup:

- [`G`](/$) and [`H`](/$) are fixed, independent generators of the group 
[`\mathbb{G}`](/$)
- [`s \overset{\$}{\leftarrow} \mathbb{Z}_p`](/$) is the secret key, uniformly
sampled from the group
- [`P = s^{-1} \cdot H`](/$) is the public key, derived from the private key 
[`s`](/$)
- [`r \overset{\$}{\leftarrow} \mathbb{Z}_p`](/$) is a random scalar used for creating
the ciphertext
- And finally, [`m`](/$) is the plaintext message, represented as a scalar

This idea decouples the message from the group elements, allowing messages
to be arbitrary scalars rather than requiring embedding into [`\mathbb{G}`](/$).

By structuring the ciphertext as [`(C, D)`](/$), where [`C`](/$) contains
both the message and randomness, and [`D`](/$) contains only the randomness tied
to the public key, it becomes easier to construct proofs about the message
without revealing it.

The decryption process of Twisted ElGamal encryption is by far the hardest
part to understand. I like to think of it as two seperate steps. Assume
in this example that [`C`](/$) and [`D`](/$) are the ciphertext components
and [`s`](/$) is the secret key generated before.

First our goal is to remove the randomness. The ciphertext includes a random 
scalar [`r`](/$), which is unknown to the decryptor. The decryptor's goal
is to remove the [`r`](/$) from the commitment [`C = r \cdot H + m \cdot G`](/$)
leaving only [`m \cdot G`](/$), from which the scalar [`m`](/$) can be recovered.

We can't directly remove [`r \cdot H`](/$) since [`r`](/$) is unknown - but we
can compute it indirectly using the decryption handle provided in the ciphertext.

Remember that the decryption handle is computed as:

```=mathtex
D = r \cdot P = r \cdot s^{-1} \cdot H
```

We can compute:

```=mathtex
s \cdot D = s \cdot r \cdot s^{-1} \cdot H = r \cdot H
```

and then subtract this from the commitment [`C`](/$):

```=mathtex
C - s \cdot D = m \cdot G + r \cdot H - r \cdot H = m \cdot G
```

and there you go: you've isolated the component [`m \cdot G`](/$). Because 
[`G`](/$) is a known generator and [`m`](/$) is assumed to be in a small enough
space (e.g. between [`0 \leq x \leq 2^{32}`](/$)), you can **brute-force** 
[`m`](/$) by checking multiples of [`G`](/$). That is, find the scalar [`m`](/$)
such that:

```=mathtex
m \cdot G = C - s \cdot D
```

For the exact method by which to solve it, I recommend reading
[The Twisted ElGamal Encryption](https://spl.solana.com/assets/files/twisted_elgamal-2115c6b1e6c62a2bb4516891b8ae9ee0.pdf)
Chapter 3.

The encryption is **hiding**, not obfuscating. You aren't relying on the hardness
of the discrete log here, but instead rely on the hiding provided by the randomizer 
[`r`](/$), and the binding provided by the commitment.


## [So why does any of this matter?]($section.id('why_it_matters'))

Pedersen commitments and ElGamal-style encryption aren't just 
mathematical curiosities - they're the bedrock of many cutting-edge 
cryptographic systems. Because of the unique properties these tools have, 
they serve as building blocks for protocols that require
trustless interaction over untrusted networks.

Zero-knowledge proofs, such as Bulletproofs, rely heavily on Pedersen commitments
to allow someone to prove knowledge of a secret (like a number in a range),
without revealing the secret itself. Likewise, Twisted ElGamal enables
users to encrypt data like transaction amounts or votes while still allowing
computations and verification on that data - essential for privacy-preserving
blockchain protocols like Monero, ZCash, and confidential transaction in general.

Beyond blockchains, these ideas extend to secure voting systems, multi-party
computation, and decentralized identity frameworks, where both privacy and 
the *ability* to verify arguments of knowledge is paramount.

Anyways, I hope you enjoyed the explanations in this post, maybe I'll
make another one in the future going into the practical implementations
and cool optimizations that can be done in this space.
